#!/bin/bash

set -euo pipefail

# Get the absolute path of the project root
project_root=$(realpath "$(dirname "$0")")
config_file="$project_root/install.conf"

print_intro() {
    clear
    echo "============================================================================"
    echo "               _             _       _     _                                "
    echo "              / \   _ __ ___| |__   | |   (_)_ __  _   ___  __              "
    echo "             / _ \ | '__/ __| '_ \  | |   | | '_ \| | | \ \/ /              "
    echo "            / ___ \| | | (__| | | | | |___| | | | | |_| |>  <               "
    echo "           /_/   \_\_|  \___|_| |_| |_____|_|_| |_|\__,_/_/\_\              "
    echo "            ____                   ___           _        _ _               "
    echo "           | __ )  __ _ ___  ___  |_ _|_ __  ___| |_ __ _| | |              "
    echo "           |  _ \ / _  / __|/ _ \  | || '_ \/ __| __/ _  | | |              "
    echo "           | |_) | (_| \__ \  __/  | || | | \__ \ || (_| | | |              "
    echo "           |____/ \__,_|___/\___| |___|_| |_|___/\__\__,_|_|_|              "
    echo "                                                                            "
    echo "============================================================================"
    echo ""
    echo "          This script will install Arch Linux with LVM and LUKS             "
    echo ""
    echo "============================================================================"
    echo ""
    echo ""
#    sleep 2
}

get_system_info() {
    echo "Getting system info..."
    # Detect hardware model and UEFI mode
    hardware_model=$(dmidecode -s system-manufacturer)
    product_name=$(dmidecode -s system-product-name)
    uefi_mode=$(dmesg | grep -i 'EFI v' > /dev/null && echo "true" || echo "false")

    # Detect processor model
    processor_model=$(lscpu | grep 'Model name' | sed 's/Model name:\s*//')

    # Memory statistics
    memory_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    memory_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    memory_total_mb=$((memory_total / 1024))
    memory_available_mb=$((memory_available / 1024))

    # Detect virtualization platform and whether it's a VM
    virtualization_platform=$(systemd-detect-virt)
    is_vm=$(if [[ $virtualization_platform != "none" ]]; then echo "true"; else echo "false"; fi)

    # Detect graphics device
    graphics_device=$(lspci | grep -i 'vga' | sed -n 's/.*: \(.*\)/\1/p')

    # Output and log system info
    echo "Hardware model detected: $hardware_model $product_name; UEFI mode: $uefi_mode"
    echo "Processor model detected: $processor_model"
    echo "Memory statistics: ${memory_available_mb}MB available out of ${memory_total_mb}MB total installed"
    echo "Virtualization detected: $virtualization_platform; is VM: $is_vm"
    echo "Graphics devices detected: dict_keys(['$graphics_device'])"
}

# Function to check for variables that need validation
set_required_vars() {
    # List of required variables with their descriptions
    local required_vars=(
        "physical_volume:Physical Volume Label"
        "volume_group:Volume Group Label"
        "disable_root:Disable root Account"
        "root_secret:Password for root account"
        "luks_secret:Password for LUKS"
        "user_name:New User Name"
        "user_secret:Password for New User"
        "hostname:Hostname"
        "default_kernel:Default Kernel"
    )

    # Source the configuration file
    source "$config_file"
   # Declare an associative array to hold the current values
    declare -A current_values
    local undefined_vars=()
    local is_password

    echo ""
    echo "Checking config for variable preset values:"

    # Check if variables are defined and prepare output
for var in "${required_vars[@]}"; do
    IFS=":" read -r var_name description <<< "$var"

    # Check for passwords by identifying "_secret" suffix
    if [[ "$var_name" == *_secret ]]; then
        is_password=1
    else
        is_password=0
    fi
    
    # Check if variable is defined
    if [[ -n "${!var_name:-}" ]]; then
        current_values["$var_name"]="${!var_name}"
        # Debug: Show the current value or indicate it's a password
        if [[ "$is_password" -eq 1 ]]; then
            echo "$description ($var_name) = ********"
        else
            echo "$description ($var_name) = ${current_values[$var_name]}"
        fi
    else
        undefined_vars+=("$var_name")
    fi
done


    # If there are undefined variables, prompt the user for input
    if ((${#undefined_vars[@]} > 0)); then
        for var in "${undefined_vars[@]}"; do
            case "$var" in
                *_secret)
                    prompt_password "$var"
                    ;;
                "disable_root")
                    prompt_boolean "$var"
                    ;;
                "default_kernel")
                    prompt_kernel "$var"
                    ;;
                *)
                    read -rp "Please enter a value for $var: " value
                    current_values["$var"]="$value"
                    ;;
            esac
        done
    fi

# In the `else` block, prompt for other undefined variables
if confirm_proceed; then
    echo "Proceeding with current values..."
else
    # Prompt to update only defined values
    for var in "${!current_values[@]}"; do
        local current="${current_values[$var]:-}"
        case "$var" in
            *_secret)
                prompt_password "$var"
                ;;
            "disable_root")
                prompt_boolean "$var"
                ;;
            "default_kernel")
                prompt_kernel "$var"
                ;;
            *)
                if [[ -n "$current" ]]; then
                    read -rp "Please enter a new value for $var (current: ${current_values[$var]}): " value
                else
                    read -rp "Please enter a value for $var:" value
                fi
                current_values["$var"]="${value:-${current_values[$var]}}"
                ;;
        esac
    done
fi
}

# Function to print the current values
print_current_values() {
    echo "Current values:"
    for var in "${required_vars[@]}"; do
        IFS=":" read -r var_name description <<< "$var"

        # Check if the variable name is a password to print appropriately
        if [[ "$var_name" == *_secret ]]; then
            echo "$description ($var_name) = ********"
        else
            echo "$description ($var_name) = ${current_values[$var_name]:-Not defined}"
        fi
    done
}

# Function to confirm if the user wants to proceed
confirm_proceed() {
    while true; do
        read -rp "Do you want to proceed with these values? (yes/no): " proceed
        case "${proceed,,}" in  # Convert input to lowercase for matching
            y|yes) return 0 ;;   # Return 0 for success (proceed)
            n|no) return 1 ;;    # Return 1 for failure (do not proceed)
            *) echo "Invalid input. Please enter 'yes' or 'no'." ;;
        esac
    done
}

# Function to prompt for password variables
prompt_password() {
    local var="$1"
    local current="${current_values[$var]:-}"

    while true; do
        if [[ -n "$current" ]]; then
            echo "Current value for $var is set. Enter a new value to change it."
        fi
        read -rsp "Please enter a value for $var: " value
        echo
        read -rsp "Please confirm the value for $var: " value_confirm
        echo
        if [[ "$value" == "$value_confirm" ]]; then
            current_values["$var"]="$value"
            break
        else
            echo "Passwords do not match. Please try again."
        fi
    done
}

# Function to prompt for boolean variables (like disable_root)
prompt_boolean() {
    local var="$1"
    local current="${current_values[$var]:-}"
    while true; do
        if [[ -n "$current" ]]; then
            echo "Current value for $var: $current. Enter a new value to change it."
        fi
        read -rp "Please enter a value for $var (true/false): " value
        if [[ "$value" == "true" || "$value" == "false" ]]; then
            current_values["$var"]="$value"
            break
        else
            echo "Invalid input for $var. It must be true or false."
        fi
    done
}

# Function to prompt for valid Arch Linux kernels
prompt_kernel() {
    local var="$1"
    local current="${current_values[$var]:-}"
    while true; do
        if [[ -n "$current" ]]; then
            echo "Current value for $var: $current. Enter a new value to change it."
        fi
        read -rp "Please enter a value for $var: " value
        if validate_kernel "$value"; then
            current_values["$var"]="$value"
            break
        else
            echo "Invalid kernel name. Please enter a valid kernel available in the Arch Linux repository."
        fi
    done
}

# Function to validate if a given kernel name is a valid Arch Linux kernel
validate_kernel() {
    local kernel_name="$1"

    case "$kernel_name" in
        "linux" | "linux-lts" | "linux-rt" | "linux-hardened" | "linux-zen")
            return 0  # Valid kernel
            ;;
        *)
            echo "Error: $kernel_name is not a valid kernel. Choose from: linux, linux-lts, linux-rt, linux-hardened, or linux-zen."
            return 1  # Not a valid kernel
            ;;
    esac
}

# Update or create a configuration variable
update_config() {
    local config_var="$1"
    local new_value="$2"

    # Escape special characters for sed
    local escaped_value
    escaped_value=$(printf '%s\n' "$new_value" | sed -e 's/[\/&]/\\&/g')

    # Check if the config variable exists in the config_file file
    if grep -q "^$config_var=" "$config_file"; then
        # Update the existing config variable with the unescaped new value
        sed -i "s|^$config_var=.*|$config_var=\"$escaped_value\"|" "$config_file"
        echo "Updated $config_var to $new_value in $config_file"
    else
        # Add the config variable with the new value to the end of the file
        echo "$config_var=\"$new_value\"" >> "$config_file"
        echo "Added $config_var with value $new_value to $config_file"
    fi
}

check_connectivity() {
    echo "Checking network connectivity..."
    if ping -c 1 www.archlinux.org &>/dev/null; then
        echo "Network connectivity is available."
        return 0
    else
        echo "No network connectivity."
        echo "Please connect to a wireless network using 'iwctl'."
        echo "To list available networks, use: 'iwctl station <device> scan && iwctl station <device> get-networks'."
        echo "To connect to a network, use: 'iwctl station <device> connect <SSID>'."
        echo "After network connectivity has been established, re-run archinstall."
        return 1
    fi
}

set_ntp() {
    echo "Setting NTP..."
    timedatectl set-ntp true
    if timedatectl show | grep -q "NTPSynchronized=yes"; then
        echo "NTP is successfully synchronized."
        return 0
    else
        echo "Warning: Unable to synchronize NTP."
        return 1
    fi
}

configure_mirrors() {
    echo "Configuring mirrors..."

    # Check to see if reflector is installed
    if ! which reflector > /dev/null; then
        echo "Installing reflector"
        pacman -Sy --noconfirm reflector
    fi

    # Update mirrors
    reflector --verbose --latest 5 --protocol https --sort score --threads 5 --save /etc/pacman.d/mirrorlist
}

check_mirrorlist_updated() {
    echo "Checking if the mirrorlist has been updated by reflector..."
    for i in {1..20}; do  # Check every 3 seconds for 60 seconds
        if grep -q "Arch Linux mirrorlist generated by Reflector" /etc/pacman.d/mirrorlist; then
            echo "Mirrorlist was updated by reflector."
            return 0
        fi
        echo "waiting..."
        sleep 3
    done
    echo "Mirrorlist was not updated within 60 seconds. Starting reflector service..."
    systemctl start reflector.service
    for i in {1..20}; do  # Additional 60 seconds to check
        if grep -q "Arch Linux mirrorlist generated by Reflector" /etc/pacman.d/mirrorlist; then
            echo "Mirrorlist was updated by reflector."
            return 0
        fi
        echo "waiting..."
        sleep 3
    done
    echo "Error: Reflector is not updating the mirrorlist."
    return 1
}

show_mountpoints() {
    #Show mountpoints
    lsblk -o NAME,SIZE,TYPE,MOUNTPOINT
}

get_install_disk() {
    read -p "Enter the disk to partition (e.g., /dev/sda or sda): " disk

    # Check if the user entered a device name without '/dev/' and prepend it
    if [[ ! "$disk" =~ ^/dev/ ]]; then
        disk="/dev/$disk"
    fi

    echo "User selected $disk"

    # Validate that the entered device is a valid block device
    if [[ ! -b "$disk" ]]; then
        echo "Error: $disk is not a valid block device."
        exit 1
    fi
}

main() {
    clear
    print_intro
    get_system_info
    set_required_vars
    check_connectivity
    set_ntp
    configure_mirrors
    check_mirrorlist_updated
    show_mountpoints
    get_install_disk
    #is_disk_encrypted_or_lvm
    #partition_disk
    #setup_luks_and_lvm
    #create_logical_volumes
    #format_logical_volumes
    #mount_filesystems
}

main

